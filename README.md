# group-commit-demo
# 对于高并发写优化TPS的简单易用方案
> a good solution and easy for high concurrent write scenario

# 高并发写优化理论
对于高并发的读QPS优化手段较多，最经济简单的方式是上缓存。但是对于高并发写TPS该如何提升？业界常用的有分库分表、异步写入等技术手段。但是分库分表对于业务的改造十分巨大，涉及迁移数据的麻烦工作，不会作为常用的优化手段。异步写入到时经常在实际工作中使用，但是也不适合所有场景，特别对于带有事务的写入请求，带事务的写入请求通常是需要同步告知用户处理结果，所以不适用异步处理。

我们都知道批处理会比单条处理快很多，只需要发起一次网络请求，在网络层面节省了N次TCP连接获取和发送数据的步骤。实际我测试过，通过shark抓包，发现建立一条TCP连接可能需要耗费10ms~50ms左右。如果是跨洲际的TCP连接更久，可能耗费几百毫秒。单是节省的多次TCP连接就能节省不少时间，其次还有程序代码的循环执行时间。所以将多个写请求聚合成一个合适大小的批量写请求，一次性将数据发送给服务器进行批量写入是最高效的。

# 后台技术架构
因为我们工作中大多数使用的是Tomcat容器，目前Tomcat的IO处理模型是Reactor+线程池的模式。  

![image](https://github.com/user-attachments/assets/0683a10a-f8a5-46d6-987f-94b924db45e3 =600*600)


在整个系统架构层面，组提交影响性能的有两个参数：组大小和等待时间。组大小就是在组内挂起等待的线程数，等待时间是Leader主动等待的毫秒数。组大小直接影响到剩余可工作的线程数，Tomcat线程数量默认200，通常我们根据业务场景和硬件资源调整，线程数量也就几百左右。如果组大小太大同时等待时间太久！！直接把Tomcat所有线程都挂起了这时服务器就假死了，所以对组大小的设置建议通过压测来确定，按照下面的压测经验一般建议设置为Tomcat线程数量的1/4~1/2。这样最大1/2能确保还有一半线程可以服务其它请求。 


# 组件架构

# Jmeter压测报告


